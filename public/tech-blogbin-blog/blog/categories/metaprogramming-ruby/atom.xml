<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: MetaProgramming Ruby | Tech.Blogbin's Blog]]></title>
  <link href="http://blogbin.github.com/tech-blogbin-blog/blog/categories/metaprogramming-ruby/atom.xml" rel="self"/>
  <link href="http://blogbin.github.com/tech-blogbin-blog/"/>
  <updated>2012-08-14T16:07:52+08:00</updated>
  <id>http://blogbin.github.com/tech-blogbin-blog/</id>
  <author>
    <name><![CDATA[Tech Blogbin ]]></name>
    <email><![CDATA[Tech Blogbin <tech.blogbin@gmail.com>]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[申思维 @sg552sg552 meta ruby programming]]></title>
    <link href="http://blogbin.github.com/tech-blogbin-blog/blog/2012/08/14/shen-si-wei-at-sg552sg552-meta-ruby-programming/"/>
    <updated>2012-08-14T12:47:00+08:00</updated>
    <id>http://blogbin.github.com/tech-blogbin-blog/blog/2012/08/14/shen-si-wei-at-sg552sg552-meta-ruby-programming</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[元编程的魅力——反射机制 - 逸光 - (_2b || ! _2b).is_a? Question]]></title>
    <link href="http://blogbin.github.com/tech-blogbin-blog/blog/2012/08/13/the-metaprogramming-charm-reflection/"/>
    <updated>2012-08-13T21:20:00+08:00</updated>
    <id>http://blogbin.github.com/tech-blogbin-blog/blog/2012/08/13/the-metaprogramming-charm-reflection</id>
    <content type="html"><![CDATA[<p>  近期在准备 MetaProgramming Ruby 元编程的培训。除了 MetaProgramming Ruby 元编程这本书之外，想参阅一下其它资源，
作为培训 PPT 的补充。毕竟 MetaProgramming Ruby 元编程 虽然蕴含的知识量不小，但相比 Ruby 元编程本身，还是稍微有点薄。</p>

<p><a href="http://www.slideshare.net/fullscreen/ihower/designing-ruby-apis/">元编程的魅力——反射机制 - 逸光 - (<em>2b || ! </em>2b).is_a? Question</a> 的读后感：</p>

<!--more-->


<h3>1. is_a?, kind_of? 和 instace_of? 的区别</h3>

<p><blockquote><p>is_a?由Object类提供并接受一个参数，参数为类名的标识符（一个常量标识符），该方法用于确认对象是否为指定类的实例。区别与instance_of?，is_a?的判定条件比较宽松，ri提供的例子就足够详细了，让我们来看看吧。</p></p><p><p>```<br/>module M; end<br/>class A; include M; end<br/>class B &lt; A; end<br/>class C &lt; B; end</p></p><p><p>b = B.new<br/>b.instance_of? A  #=> false<br/>b.instance_of? B  #=> true<br/>b.instance_of? C  #=> false<br/>b.instance_of? M  #=> false</p></p><p><p>b.kind_of? A      #=> true<br/>b.kind_of? B      #=> true<br/>b.kind_of? C      #=> false<br/>b.kind_of? M      #=> true<br/>```</p></p><p><p>如果给定的类，是直接生成对象的类，那么，instance_of?方法才返回true。而如果是直接生成对象的类的父类或者引用的模块、父类引用的模块发，instance_of?就会无情的返回false。不过不要紧，kind_of?方法（is_a?方法也如此）会返回true的。</p></p><p><p></p></blockquote></p>

<h3>2. Module#included_modules 返回一个模块或类包含的模块</h3>

<p><blockquote><p>module类的实例方法included_modules 可以返回一个模块或类包含的模块（Class继承自Module，自然继承了此方法）。<br/><code><br/>irb(main):033:0]]&gt; B.included_modules<br/>=&gt; [M, Kernel]<br/></code><br/>Kernel模块，诚如教科书所写，他包含在每一个类或模块里，这样才使得Ruby中有了“函数”。</p></blockquote></p>

<h3>3. 而Object#singleton_methods方法同样以数组的方式返回对象的 eigenclass 方法</h3>

<p><blockquote><p>而Object#singleton_methods方法同样以数组的方式返回对象的单例方法（Singleton Method）。<br/><code><br/>irb(main):007:0&gt; Math.singleton_methods<br/>=&gt; [:atan2, :cos, :sin, :tan, :acos, :asin, :atan, :cosh, :sinh, :tanh, :acosh,:asinh, :atanh, :exp, :log, :log2, :log10, :sqrt, :cbrt, :frexp, :ldexp, :hypot, :erf, :erfc, :gamma, :lgamma]<br/></code></p></blockquote></p>

<h3>4. Fixnum 的对象和 Symbol 的对象一样不可变</h3>

<p><blockquote><p>使用object_id获取对象的一个全局id，可以用于确定对象是不是同一个对象。<br/>```<br/>irb(main):010:0]]&gt; 1.object_id == 1.object_id<br/>=> true</p></p><p><p>irb(main):011:0]]&gt; "obj".object_id == "obj".object_id<br/>=> false</p></p><p><p>irb(main):012:0]]&gt; :sym.object_id == :sym.object_id<br/>=> true<br/>```<br/>　　Fixnum类的实例都是立即数因此只有一个副本，Symbol类的对象也一样，但是其他类的可能就不一样咯~</p></blockquote></p>
]]></content>
  </entry>
  
</feed>
