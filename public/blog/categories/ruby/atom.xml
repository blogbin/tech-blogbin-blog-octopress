<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Tech.Blogbin's Blog]]></title>
  <link href="http://tech-blog.blogbin.info/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://tech-blog.blogbin.info/"/>
  <updated>2012-08-16T09:06:54+08:00</updated>
  <id>http://tech-blog.blogbin.info/</id>
  <author>
    <name><![CDATA[Tech Blogbin ]]></name>
    <email><![CDATA[Tech Blogbin <tech.blogbin@gmail.com>]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby和元编程的故事 - 第1回: 色色空空，万物皆为对象]]></title>
    <link href="http://tech-blog.blogbin.info/blog/2012/08/16/a-story-about-ruby-and-programming-ruby-1/"/>
    <updated>2012-08-16T08:01:00+08:00</updated>
    <id>http://tech-blog.blogbin.info/blog/2012/08/16/a-story-about-ruby-and-programming-ruby-1</id>
    <content type="html"><![CDATA[<p>参阅：
Hisea <a href="http://hisea.me/">http://hisea.me/</a></p>

<p>的Ruby和元编程的故事 - 第0回: 欲练神功，必先自废武功 <a href="http://ruby-china.org/topics/1171">http://ruby-china.org/topics/1171</a></p>

<h5>1. 官方说法是 eigenclass 本体类</h5>

<p>有很多名字，比如单例类，估计是因为 eigenclass 本体类很容易就解决设计模式的单例，结果就误传下来了。
<blockquote><p>Singleton/Meta/Anonymous/Ghost/Shadow Class</p></p><p><ul><br/><li> Singleton Class: 单例类</li><br/><li> Meta Class：元类</li><br/><li> Anonymous Class: 匿名类</li><br/><li> Ghost Class：鬼类</li><br/><li> Shadow Class: 影子类<br/>上面的这些东东其实说的都是一个东西，我喜欢叫它 影子类。</p></blockquote></li>
</ul>


<!--more-->


<h5>2. 关于 Object#dup 和 Object#clone 的区别</h5>

<p><blockquote><p>对象的复制<br/>前文说对象的存在包括两部分，一是状态/实例变量，另一个是行为，本回专注讲了单例方法和影子类。</p></p><p><p>Ruby中对象的复制也有两种模式，一个是只复制当前的状态/实例变量 dup。另外一种是连同影子类和引用的对象一起复制，从而把单例方法也复制一份。<br/>``` ruby</p></p><p><blockquote><blockquote><p>a = "obj"<br/>def a.hello_self<br/>puts "hello #{self}"<br/>end<br/>b = a.dup<br/>=> "obj"<br/>b.hello_self<br/>NoMethodError: undefined method `hello_self' for "obj":String</p></p><p><pre><code>from (irb):90<br/></code></pre></p><p><p>b = a.clone<br/>=> "obj"<br/>b.hello_self<br/>hello obj<br/>```</p></blockquote></blockquote></p><p><p>其实有本回上述的这些功能，即便是没有class，Ruby也可以作为一种Prototype(类似JavaScript)的面向对象语言了。</p></p><p><p>你可以建立一个对象，生成默认的实例变量，把行为作为单例方法定以在这个对象的影子类上，然后用clone生成千千万万个实例。当然这样比较麻烦，但却是可行的途径之一。</p></p><p><p>其他Object API<br/>对象还有很多其他的功能，比如可以freeze,另外dup跟clone也有一些其他的引用上面的区别，dup只复制引用，clone会吧引用的对象也复制。</p></p><p><p>这些都可以在Object类(Ruby所有对象的父类)API上找到，可以查看apidock.com的文档</p></p><p><p>例如关于dup</p></p><p><p>.dup() produces a shallow copy of obj—the instance variables of obj are copied, but not the objects they reference. dup copies the tainted state of obj. See also the discussion under Object#clone. In general, clone and dup may have different semantics in descendant classes. While clone is used to duplicate an object, including its internal state, dup typically uses the class of the descendant object to create the new instance.</p></blockquote></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby和元编程的故事 - 第0回: 欲练神功，必先自废武功]]></title>
    <link href="http://tech-blog.blogbin.info/blog/2012/08/16/a-story-about-ruby-and-metaprogramming-ruby-0/"/>
    <updated>2012-08-16T08:01:00+08:00</updated>
    <id>http://tech-blog.blogbin.info/blog/2012/08/16/a-story-about-ruby-and-metaprogramming-ruby-0</id>
    <content type="html"><![CDATA[<p>参阅：
Hisea <a href="http://hisea.me/">http://hisea.me/</a></p>

<p>的Ruby和元编程的故事 - 第0回: 欲练神功，必先自废武功</p>

<p><a href="http://ruby-china.org/topics/1171">http://ruby-china.org/topics/1171</a></p>

<p>介绍了 Ruby 和元编程的一些特点，主要是在一些思维上的改变，特别是从 Java 等其它语言过来的人。</p>

<h5>1. 注意动态语言和动态类型的区别，动态类型仅为动态语言其中一个部分。</h5>

<p><blockquote><p>动态语言:<br/>动态语言的定义还很模糊，很多人把动态语言跟动态类型语言搞混，对于Hisea来说，动态语言就是类，方法，及其他定义可以在运行时进行改变，元编程就是利用这一特性。由此可见，动态语言跟动态类型语言并不是一个概念.</p></blockquote></p>

<!--more-->


<h5>2. 推崇模块混入或者扩展的方式增加 API 功能，而非事事皆继承。</h5>

<p>ps: 打开类也是一种途径。
<blockquote><p>父类的作用仅仅是定义了API的存在，这在Java中是非常常见的，可是在Ruby中，这个父类其实存在的意义不是特别大。Ruby更倾向于,任何能起飞(拥有‘起飞’方法)的对象都是飞行器，而不是任何继承飞行器的类的对象。</p></p><p><ol><br/><li>需要用继承分享代码么？ ActiveRecord需要你继承ActiveRecord::Base,例如:<br/><code>ruby<br/>class Post &lt; ActiveRecord::Base  <br/>end<br/></code><br/>Hisea本人觉得类似Mongoid的Mixin方式更适合解决类似的问题。 Post从设计逻辑上来讲,跟ActiveRecord::Base没有半毛钱关系。继承关系完全用于分享代码，而在Ruby中，更好的分享代码的办法是用Mixin.</p></blockquote></li>
</ol>


<h5>3. 个人认为 UML 仍是需要的</h5>

<p>特别是项目中涉及到十几以上模型的时候，模型相互之间关系通过 UML 等方式更容易展现。关键是要及时更新和维护。
<blockquote><p>4,忘记UML(或其他)设计大法<br/>这个话题是3的继续，公司新招了一个Ruby程序员，他来了一两个星期后问了个问题，问为什么公司(或者其他Ruby程序员)不爱用UML之类的设计工具，当时我也一时找不出答案，后来开车回家的路上用半个小时想明白了，UML是一个类只见关系的静态表示，Ruby运行时的情况却是不停在变幻。用静态去表示动态，自然捉襟见肘。</p></blockquote></p>

<h5>4. 好的 IDE 对 Ruby 开发有一定好处的</h5>

<p>比如  RubyMine :</p>

<ol>
<li>调试功能不错，可以运行时调试，设置断点，查看变量。。。</li>
<li>支持一定类，模块，动法以及变量的查找，遇上 IDE 无法直接识别的，会列一个清单让用户选择</li>
</ol>


<p>唯一不好的地方就是，RubyMine 是用 Java 做的，占内存，运行有时会卡，最好机器配置为 intel Core i5，8 G 内存以上，用 SSD 固态硬盘更好。</p>

<p><blockquote><p>5.为什么不用IDE?<br/>很多从Java阵营转来，尤其是有多年eclipse经验的Ruby初学者尤其是经常爱问，Ruby用什么IDE。</p></p><p><p>得到的回答往往是text mate,vim,sublime text 2等等文本编辑器。</p></p><p><p>很多人可能纳闷，为什么Ruby/Rails没有一个IDE占领大片江山的情况，为什么Netbeans／Eclipse再Ruby开发阵营中没有其他语言开发占的地位重要。</p></p><p><p>其实答案很简单。</p></p><p><ol><br/><li>IDE最讨喜的功能是什么？</li><br/></ol></p><p><br/><p>很多用惯了IDE开发的Java程序员甚至XCode程序员，都会说最爱的功能是代码不全，object之后按一下'.'立马生成一个方法列表。转到Ruby用文本编辑器，没有这个功能，很是郁闷。其实道理很简单，如果方法都是动态生成的，在写程序的时候怎么能给出一个列表呢。</p></p><p><ol><br/><li>Debugger还是必要工具么？</li><br/></ol></p><p><br/><p>静态语言开发，调试是居家旅行杀人灭口必备良药。而IDE又是调试的好帮手。</p></p><p><p>Ruby／Rails的Debugger还没那么成熟，而且如果用logger, raise在适当的地方输出inspect, to_yaml等内容，也可以很容易的找到错误。</p></p><p><ol><br/><li>Eclipse可以很好的配置Java开发环境。</li><br/></ol></p><p><br/><p>Ruby/Rails有好用的RVM,RubyGems,Bundler.</p></p><p><p>所以，不补全，不调试，不配环境，要IDE不也是拿来当文本编辑器用么</p></blockquote></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redmine 改进：新建问题发送邮件中显示完成时间和上传的附件信息]]></title>
    <link href="http://tech-blog.blogbin.info/blog/2012/08/15/displaying-attachments-and-due-date-within-email-when-a-issue-is-created/"/>
    <updated>2012-08-15T23:44:00+08:00</updated>
    <id>http://tech-blog.blogbin.info/blog/2012/08/15/displaying-attachments-and-due-date-within-email-when-a-issue-is-created</id>
    <content type="html"><![CDATA[<p>Redmine <a href="http://www.redmine.org/">http://www.redmine.org/</a> 的确是一款优秀的任务跟踪管理系统，是开源免费，而且是基于 RubyOnRails 来开发的 Web 系统，代码具有很强的学习的价值。</p>

<p>很奇怪为何新建问题，系统自动发送的邮件没有显示要求完成时间和附件信息，而更新问题时发送的邮件却有两者信息。</p>

<p>阅读代码后发现，Redmine 负责渲染新建问题自动发送的邮件的地方，没有显示要求完成时间和附件信息。</p>

<p>要求完成时间比较好好处理，直接从 @issue.due_date 获得；</p>

<p>但新建问题后，就触发 Observer 自动发邮件，此时上传过的附件还没保存入库，所以利用现有途径无法从 @issue 获得附件。</p>

<p>尝试好几种方案，均不成功。最后考虑给 Issue 模型加一个实例变量临时保存附件信息。</p>

<p>Redmine 版本基于 1.2.1</p>

<p>与邮件正文内容显示相关的关键代码在 show_detail.rb 的 show_detail() 方法：</p>

<p><a href="https://github.com/redmine/redmine/blob/master/app/helpers/issues_helper.rb">https://github.com/redmine/redmine/blob/master/app/helpers/issues_helper.rb</a></p>

<p>具体调整如下：</p>

<!--more-->


<h5>1. 打开 Issue 类，添加新的实例变量 original_attachments，用于临时保存刚上传的附件</h5>

<p>``` ruby
class Issue &lt; ActiveRecord::Base</p>

<p>  attr_accessor :original_attachments</p>

<p>end
```</p>

<h5>2. 修改 IssuesController#create 方法</h5>

<p>``` ruby issues_controller.rb
def create</p>

<pre><code>call_hook(:controller_issues_new_before_save, { :params =&gt; params, :issue =&gt; @issue })

# 对 @issue.original_attachments 进行赋值
@issue.original_attachments = params[:attachments]

if @issue.save

# ... 以下省略
</code></pre>

<p>  end
```</p>

<h5>3. 渲染邮件格式的地方补充显示要求完成时间和附件信息</h5>

<p>``` ruby issue_add_text_html.rhtml
&lt;%= l(:text_issue_added, :id => "##{@issue.id}", :author => h(@issue.author)) %></p>

<p>&lt;%
  # 显示完成时间信息
  if @issue.due_date
%></p>

<ul>
  <li><%= l(:text_journal_set_to, :label => l(:field_due_date), :value => format_date( @issue.due_date ) ) %> </li>
</ul>


<p>&lt;% end %></p>

<p>&lt;%
  # 显示附件信息
  attachments = @issue.original_attachments
  puts "attachments = #{attachments}"
  if attachments &amp;&amp; attachments.is_a?(Hash)
%></p>

<pre><code>&lt;ul&gt;
        &lt;%
        attachments.each_value do |attachment|
          file = attachment['file']
          next unless file &amp;&amp; file.size &gt; 0
        %&gt;
            &lt;li&gt;&lt;%= l(:text_journal_added, :label =&gt; l(:label_attachment), :value =&gt; file.original_filename ) %&gt; &lt;/li&gt;
    &lt;% end %&gt;
&lt;/ul&gt;
</code></pre>

<p>&lt;% end %></p>

<hr />


<p>&lt;%= render :partial => "issue_text_html", :locals => { :issue => @issue, :issue_url => @issue_url } %></p>

<p>```</p>

<h5>4. 最终效果如图</h5>

<p><blockquote><p><img src="/images/2012-08-15-displaying-attachments-and-due-date-within-email-when-a-issue-is-created/redmine_issue_add_email.png"></p></blockquote></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[申思维 @sg552sg552 meta ruby programming]]></title>
    <link href="http://tech-blog.blogbin.info/blog/2012/08/14/shen-si-wei-at-sg552sg552-meta-ruby-programming/"/>
    <updated>2012-08-14T12:47:00+08:00</updated>
    <id>http://tech-blog.blogbin.info/blog/2012/08/14/shen-si-wei-at-sg552sg552-meta-ruby-programming</id>
    <content type="html"><![CDATA[<p>申思维 @sg552sg552 非常热情，主动告知我 PPT 的下载地址，非常感谢！</p>

<p>参阅：</p>

<p>[北京][2012年08月11日] Ruby 活动公告+媒体资料+小结 » 社区 | Ruby China
<a href="http://ruby-china.org/topics/4662">http://ruby-china.org/topics/4662</a></p>

<p>PPT：meta programming ruby // Speaker Deck
<a href="https://speakerdeck.com/u/sg552sg552/p/meta-programming-ruby">https://speakerdeck.com/u/sg552sg552/p/meta-programming-ruby</a></p>

<p>MP3：<a href="http://vdisk.weibo.com/s/alUOz">http://vdisk.weibo.com/s/alUOz</a></p>

<p>一些总结：</p>

<!--more-->


<h5>1. const_set 和 const_get 操作常量的用法</h5>

<p><blockquote><p><img src="/images/2012-08-14-shen-si-wei-at-sg552sg552-meta-ruby-programming/core_methods.jpeg"></p></blockquote></p>

<h5>2. 举例子说明：动态方法的好处，减少代码冗余</h5>

<p><blockquote><p><img src="/images/2012-08-14-shen-si-wei-at-sg552sg552-meta-ruby-programming/refactoring.jpeg"></p></blockquote></p>

<h5>3. %Q{} 语法使用，表示一行字符串</h5>

<p><blockquote><p><img src="/images/2012-08-14-shen-si-wei-at-sg552sg552-meta-ruby-programming/basic_class_eval.jpeg"></p></blockquote></p>

<h5>4. class_variables，class_variable_defined? 和 <em>get, </em>set 方法的使用</h5>

<p><blockquote><p><img src="/images/2012-08-14-shen-si-wei-at-sg552sg552-meta-ruby-programming/basic_class_variables.jpeg"></p></blockquote></p>

<h5>5. remove_const 和 const_set 对常量的动态操作</h5>

<p><blockquote><p><img src="/images/2012-08-14-shen-si-wei-at-sg552sg552-meta-ruby-programming/substitude_class.jpeg"></p></blockquote></p>

<p>想了半天才明白，Symbal 估计实现 Symbal#to_proc 方法：</p>

<p>``` ruby
class Symbal
  def to_proc</p>

<pre><code>Proc.new { | x | x.send self }
</code></pre>

<p>  end
end
```</p>

<h5>6. 适合迭代中，对每一个其中的元素做一次 Symbal 对象对应的方法调用。</h5>

<p><blockquote><p><img src="/images/2012-08-14-shen-si-wei-at-sg552sg552-meta-ruby-programming/symbol_to_proc.jpeg"></p></blockquote></p>

<h5>7. stub 方法实现测试中 Mock 的功能，估计 stub 方法实现是通过 Module#define_method 重新定义了方法，返回代码块执行的结果。</h5>

<p><blockquote><p><img src="/images/2012-08-14-shen-si-wei-at-sg552sg552-meta-ruby-programming/symbol_to_proc.jpeg"></p></blockquote></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[元编程的魅力——反射机制 - 逸光 - (_2b || ! _2b).is_a? Question]]></title>
    <link href="http://tech-blog.blogbin.info/blog/2012/08/13/the-metaprogramming-charm-reflection/"/>
    <updated>2012-08-13T21:20:00+08:00</updated>
    <id>http://tech-blog.blogbin.info/blog/2012/08/13/the-metaprogramming-charm-reflection</id>
    <content type="html"><![CDATA[<p>  近期在准备 MetaProgramming Ruby 元编程的培训。除了 MetaProgramming Ruby 元编程这本书之外，想参阅一下其它资源，
作为培训 PPT 的补充。毕竟 MetaProgramming Ruby 元编程 虽然蕴含的知识量不小，但相比 Ruby 元编程本身，还是稍微有点薄。</p>

<p><a href="http://www.slideshare.net/fullscreen/ihower/designing-ruby-apis/">元编程的魅力——反射机制 - 逸光 - (<em>2b || ! </em>2b).is_a? Question</a> 的读后感：</p>

<!--more-->


<h3>1. is_a?, kind_of? 和 instace_of? 的区别</h3>

<p><blockquote><p>is_a?由Object类提供并接受一个参数，参数为类名的标识符（一个常量标识符），该方法用于确认对象是否为指定类的实例。区别与instance_of?，is_a?的判定条件比较宽松，ri提供的例子就足够详细了，让我们来看看吧。</p></p><p><p>```<br/>module M; end<br/>class A; include M; end<br/>class B &lt; A; end<br/>class C &lt; B; end</p></p><p><p>b = B.new<br/>b.instance_of? A  #=> false<br/>b.instance_of? B  #=> true<br/>b.instance_of? C  #=> false<br/>b.instance_of? M  #=> false</p></p><p><p>b.kind_of? A      #=> true<br/>b.kind_of? B      #=> true<br/>b.kind_of? C      #=> false<br/>b.kind_of? M      #=> true<br/>```</p></p><p><p>如果给定的类，是直接生成对象的类，那么，instance_of?方法才返回true。而如果是直接生成对象的类的父类或者引用的模块、父类引用的模块发，instance_of?就会无情的返回false。不过不要紧，kind_of?方法（is_a?方法也如此）会返回true的。</p></p><p><p></p></blockquote></p>

<h3>2. Module#included_modules 返回一个模块或类包含的模块</h3>

<p><blockquote><p>module类的实例方法included_modules 可以返回一个模块或类包含的模块（Class继承自Module，自然继承了此方法）。<br/><code><br/>irb(main):033:0]]&gt; B.included_modules<br/>=&gt; [M, Kernel]<br/></code><br/>Kernel模块，诚如教科书所写，他包含在每一个类或模块里，这样才使得Ruby中有了“函数”。</p></blockquote></p>

<h3>3. 而Object#singleton_methods方法同样以数组的方式返回对象的 eigenclass 方法</h3>

<p><blockquote><p>而Object#singleton_methods方法同样以数组的方式返回对象的单例方法（Singleton Method）。<br/><code><br/>irb(main):007:0&gt; Math.singleton_methods<br/>=&gt; [:atan2, :cos, :sin, :tan, :acos, :asin, :atan, :cosh, :sinh, :tanh, :acosh,:asinh, :atanh, :exp, :log, :log2, :log10, :sqrt, :cbrt, :frexp, :ldexp, :hypot, :erf, :erfc, :gamma, :lgamma]<br/></code></p></blockquote></p>

<h3>4. Fixnum 的对象和 Symbol 的对象一样不可变</h3>

<p><blockquote><p>使用object_id获取对象的一个全局id，可以用于确定对象是不是同一个对象。<br/>```<br/>irb(main):010:0]]&gt; 1.object_id == 1.object_id<br/>=> true</p></p><p><p>irb(main):011:0]]&gt; "obj".object_id == "obj".object_id<br/>=> false</p></p><p><p>irb(main):012:0]]&gt; :sym.object_id == :sym.object_id<br/>=> true<br/>```<br/>　　Fixnum类的实例都是立即数因此只有一个副本，Symbol类的对象也一样，但是其他类的可能就不一样咯~</p></blockquote></p>
]]></content>
  </entry>
  
</feed>
