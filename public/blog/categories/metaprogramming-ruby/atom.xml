<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: MetaProgramming Ruby | Tech.Blogbin's Blog]]></title>
  <link href="http://tech-blog.blogbin.info/blog/categories/metaprogramming-ruby/atom.xml" rel="self"/>
  <link href="http://tech-blog.blogbin.info/"/>
  <updated>2012-08-16T00:12:42+08:00</updated>
  <id>http://tech-blog.blogbin.info/</id>
  <author>
    <name><![CDATA[Tech Blogbin ]]></name>
    <email><![CDATA[Tech Blogbin <tech.blogbin@gmail.com>]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[申思维 @sg552sg552 meta ruby programming]]></title>
    <link href="http://tech-blog.blogbin.info/blog/2012/08/14/shen-si-wei-at-sg552sg552-meta-ruby-programming/"/>
    <updated>2012-08-14T12:47:00+08:00</updated>
    <id>http://tech-blog.blogbin.info/blog/2012/08/14/shen-si-wei-at-sg552sg552-meta-ruby-programming</id>
    <content type="html"><![CDATA[<p>申思维 @sg552sg552 非常热情，主动告知我 PPT 的下载地址，非常感谢！</p>

<p>参阅：</p>

<p>[北京][2012年08月11日] Ruby 活动公告+媒体资料+小结 » 社区 | Ruby China
<a href="http://ruby-china.org/topics/4662">http://ruby-china.org/topics/4662</a></p>

<p>PPT：meta programming ruby // Speaker Deck
<a href="https://speakerdeck.com/u/sg552sg552/p/meta-programming-ruby">https://speakerdeck.com/u/sg552sg552/p/meta-programming-ruby</a></p>

<p>MP3：<a href="http://vdisk.weibo.com/s/alUOz">http://vdisk.weibo.com/s/alUOz</a></p>

<p>一些总结：</p>

<!--more-->


<h5>1. const_set 和 const_get 操作常量的用法</h5>

<p><blockquote><p><img src="/images/2012-08-14-shen-si-wei-at-sg552sg552-meta-ruby-programming/core_methods.jpeg"></p></blockquote></p>

<h5>2. 举例子说明：动态方法的好处，减少代码冗余</h5>

<p><blockquote><p><img src="/images/2012-08-14-shen-si-wei-at-sg552sg552-meta-ruby-programming/refactoring.jpeg"></p></blockquote></p>

<h5>3. %Q{} 语法使用，表示一行字符串</h5>

<p><blockquote><p><img src="/images/2012-08-14-shen-si-wei-at-sg552sg552-meta-ruby-programming/basic_class_eval.jpeg"></p></blockquote></p>

<h5>4. class_variables，class_variable_defined? 和 <em>get, </em>set 方法的使用</h5>

<p><blockquote><p><img src="/images/2012-08-14-shen-si-wei-at-sg552sg552-meta-ruby-programming/basic_class_variables.jpeg"></p></blockquote></p>

<h5>5. remove_const 和 const_set 对常量的动态操作</h5>

<p><blockquote><p><img src="/images/2012-08-14-shen-si-wei-at-sg552sg552-meta-ruby-programming/substitude_class.jpeg"></p></blockquote></p>

<p>想了半天才明白，Symbal 估计实现 Symbal#to_proc 方法：</p>

<p>``` ruby
class Symbal
  def to_proc</p>

<pre><code>Proc.new { | x | x.send self }
</code></pre>

<p>  end
end
```</p>

<h5>6. 适合迭代中，对每一个其中的元素做一次 Symbal 对象对应的方法调用。</h5>

<p><blockquote><p><img src="/images/2012-08-14-shen-si-wei-at-sg552sg552-meta-ruby-programming/symbol_to_proc.jpeg"></p></blockquote></p>

<h5>7. stub 方法实现测试中 Mock 的功能，估计 stub 方法实现是通过 Module#define_method 重新定义了方法，返回代码块执行的结果。</h5>

<p><blockquote><p><img src="/images/2012-08-14-shen-si-wei-at-sg552sg552-meta-ruby-programming/symbol_to_proc.jpeg"></p></blockquote></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[元编程的魅力——反射机制 - 逸光 - (_2b || ! _2b).is_a? Question]]></title>
    <link href="http://tech-blog.blogbin.info/blog/2012/08/13/the-metaprogramming-charm-reflection/"/>
    <updated>2012-08-13T21:20:00+08:00</updated>
    <id>http://tech-blog.blogbin.info/blog/2012/08/13/the-metaprogramming-charm-reflection</id>
    <content type="html"><![CDATA[<p>  近期在准备 MetaProgramming Ruby 元编程的培训。除了 MetaProgramming Ruby 元编程这本书之外，想参阅一下其它资源，
作为培训 PPT 的补充。毕竟 MetaProgramming Ruby 元编程 虽然蕴含的知识量不小，但相比 Ruby 元编程本身，还是稍微有点薄。</p>

<p><a href="http://www.slideshare.net/fullscreen/ihower/designing-ruby-apis/">元编程的魅力——反射机制 - 逸光 - (<em>2b || ! </em>2b).is_a? Question</a> 的读后感：</p>

<!--more-->


<h3>1. is_a?, kind_of? 和 instace_of? 的区别</h3>

<p><blockquote><p>is_a?由Object类提供并接受一个参数，参数为类名的标识符（一个常量标识符），该方法用于确认对象是否为指定类的实例。区别与instance_of?，is_a?的判定条件比较宽松，ri提供的例子就足够详细了，让我们来看看吧。</p></p><p><p>```<br/>module M; end<br/>class A; include M; end<br/>class B &lt; A; end<br/>class C &lt; B; end</p></p><p><p>b = B.new<br/>b.instance_of? A  #=> false<br/>b.instance_of? B  #=> true<br/>b.instance_of? C  #=> false<br/>b.instance_of? M  #=> false</p></p><p><p>b.kind_of? A      #=> true<br/>b.kind_of? B      #=> true<br/>b.kind_of? C      #=> false<br/>b.kind_of? M      #=> true<br/>```</p></p><p><p>如果给定的类，是直接生成对象的类，那么，instance_of?方法才返回true。而如果是直接生成对象的类的父类或者引用的模块、父类引用的模块发，instance_of?就会无情的返回false。不过不要紧，kind_of?方法（is_a?方法也如此）会返回true的。</p></p><p><p></p></blockquote></p>

<h3>2. Module#included_modules 返回一个模块或类包含的模块</h3>

<p><blockquote><p>module类的实例方法included_modules 可以返回一个模块或类包含的模块（Class继承自Module，自然继承了此方法）。<br/><code><br/>irb(main):033:0]]&gt; B.included_modules<br/>=&gt; [M, Kernel]<br/></code><br/>Kernel模块，诚如教科书所写，他包含在每一个类或模块里，这样才使得Ruby中有了“函数”。</p></blockquote></p>

<h3>3. 而Object#singleton_methods方法同样以数组的方式返回对象的 eigenclass 方法</h3>

<p><blockquote><p>而Object#singleton_methods方法同样以数组的方式返回对象的单例方法（Singleton Method）。<br/><code><br/>irb(main):007:0&gt; Math.singleton_methods<br/>=&gt; [:atan2, :cos, :sin, :tan, :acos, :asin, :atan, :cosh, :sinh, :tanh, :acosh,:asinh, :atanh, :exp, :log, :log2, :log10, :sqrt, :cbrt, :frexp, :ldexp, :hypot, :erf, :erfc, :gamma, :lgamma]<br/></code></p></blockquote></p>

<h3>4. Fixnum 的对象和 Symbol 的对象一样不可变</h3>

<p><blockquote><p>使用object_id获取对象的一个全局id，可以用于确定对象是不是同一个对象。<br/>```<br/>irb(main):010:0]]&gt; 1.object_id == 1.object_id<br/>=> true</p></p><p><p>irb(main):011:0]]&gt; "obj".object_id == "obj".object_id<br/>=> false</p></p><p><p>irb(main):012:0]]&gt; :sym.object_id == :sym.object_id<br/>=> true<br/>```<br/>　　Fixnum类的实例都是立即数因此只有一个副本，Symbol类的对象也一样，但是其他类的可能就不一样咯~</p></blockquote></p>
]]></content>
  </entry>
  
</feed>
